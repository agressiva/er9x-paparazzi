# 1 "../src/menus.cpp"
# 1 "/home/erez/Desktop/er9x/er9x/OBJS//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "../src/menus.cpp"
# 17 "../src/menus.cpp"
# 1 "../src/er9x.h" 1
# 21 "../src/er9x.h"
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/inttypes.h" 1 3
# 37 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/inttypes.h" 3
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdint.h" 1 3
# 121 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdint.h" 3
typedef int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 142 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdint.h" 3
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 159 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdint.h" 3
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 213 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdint.h" 3
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 273 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdint.h" 3
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;
# 38 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/inttypes.h" 2 3
# 77 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/inttypes.h" 3
typedef int32_t int_farptr_t;



typedef uint32_t uint_farptr_t;
# 22 "../src/er9x.h" 2
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/string.h" 1 3
# 45 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/string.h" 3
# 1 "/usr/lib/gcc/avr/4.3.4/include/stddef.h" 1 3 4
# 214 "/usr/lib/gcc/avr/4.3.4/include/stddef.h" 3 4
typedef unsigned int size_t;
# 46 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/string.h" 2 3
# 56 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/string.h" 3
extern "C" {
# 111 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/string.h" 3
extern int ffs (int __val) __attribute__((__const__));
extern int ffsl (long __val) __attribute__((__const__));
extern int ffsll (long long __val) __attribute__((__const__));
extern void *memccpy(void *, const void *, int, size_t);
extern void *memchr(const void *, int, size_t) __attribute__((__pure__));
extern int memcmp(const void *, const void *, size_t) __attribute__((__pure__));
extern void *memcpy(void *, const void *, size_t);
extern void *memmem(const void *, size_t, const void *, size_t) __attribute__((__pure__));
extern void *memmove(void *, const void *, size_t);
extern void *memrchr(const void *, int, size_t) __attribute__((__pure__));
extern void *memset(void *, int, size_t);
extern char *strcat(char *, const char *);
extern char *strchr(const char *, int) __attribute__((__pure__));
extern char *strchrnul(const char *, int) __attribute__((__pure__));
extern int strcmp(const char *, const char *) __attribute__((__pure__));
extern char *strcpy(char *, const char *);
extern int strcasecmp(const char *, const char *) __attribute__((__pure__));
extern char *strcasestr(const char *, const char *) __attribute__((__pure__));
extern size_t strcspn(const char *__s, const char *__reject) __attribute__((__pure__));
extern char *strdup(const char *s1);
extern size_t strlcat(char *, const char *, size_t);
extern size_t strlcpy(char *, const char *, size_t);
extern size_t strlen(const char *) __attribute__((__pure__));
extern char *strlwr(char *);
extern char *strncat(char *, const char *, size_t);
extern int strncmp(const char *, const char *, size_t) __attribute__((__pure__));
extern char *strncpy(char *, const char *, size_t);
extern int strncasecmp(const char *, const char *, size_t) __attribute__((__pure__));
extern size_t strnlen(const char *, size_t) __attribute__((__pure__));
extern char *strpbrk(const char *__s, const char *__accept) __attribute__((__pure__));
extern char *strrchr(const char *, int) __attribute__((__pure__));
extern char *strrev(char *);
extern char *strsep(char **, const char *);
extern size_t strspn(const char *__s, const char *__accept) __attribute__((__pure__));
extern char *strstr(const char *, const char *) __attribute__((__pure__));
extern char *strtok(char *, const char *);
extern char *strtok_r(char *, const char *, char **);
extern char *strupr(char *);


}
# 23 "../src/er9x.h" 2






# 1 "/usr/lib/gcc/avr/4.3.4/include/stddef.h" 1 3 4
# 152 "/usr/lib/gcc/avr/4.3.4/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 30 "../src/er9x.h" 2
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 1 3
# 99 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 3
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/sfr_defs.h" 1 3
# 100 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 2 3
# 176 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 3
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/iom64.h" 1 3
# 177 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 2 3
# 368 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 3
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/portpins.h" 1 3
# 369 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 2 3

# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/common.h" 1 3
# 371 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 2 3

# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/version.h" 1 3
# 373 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 2 3


# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/fuse.h" 1 3
# 234 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/fuse.h" 3
typedef struct
{
    unsigned char low;
    unsigned char high;
    unsigned char extended;
} __fuse_t;
# 376 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 2 3


# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/lock.h" 1 3
# 379 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h" 2 3
# 31 "../src/er9x.h" 2
# 43 "../src/er9x.h"
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/pgmspace.h" 1 3
# 81 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/pgmspace.h" 3
# 1 "/usr/lib/gcc/avr/4.3.4/include/stddef.h" 1 3 4
# 82 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/pgmspace.h" 2 3
# 106 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/pgmspace.h" 3
extern "C" {
# 211 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/pgmspace.h" 3
typedef void prog_void __attribute__((__progmem__));
typedef char prog_char __attribute__((__progmem__));
typedef unsigned char prog_uchar __attribute__((__progmem__));

typedef int8_t prog_int8_t __attribute__((__progmem__));
typedef uint8_t prog_uint8_t __attribute__((__progmem__));
typedef int16_t prog_int16_t __attribute__((__progmem__));
typedef uint16_t prog_uint16_t __attribute__((__progmem__));
typedef int32_t prog_int32_t __attribute__((__progmem__));
typedef uint32_t prog_uint32_t __attribute__((__progmem__));

typedef int64_t prog_int64_t __attribute__((__progmem__));
typedef uint64_t prog_uint64_t __attribute__((__progmem__));
# 848 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/pgmspace.h" 3
extern const prog_void * memchr_P(const prog_void *, int __val, size_t __len) __attribute__((__const__));
extern int memcmp_P(const void *, const prog_void *, size_t) __attribute__((__pure__));
extern void *memcpy_P(void *, const prog_void *, size_t);
extern void *memmem_P(const void *, size_t, const prog_void *, size_t) __attribute__((__pure__));
extern const prog_void * memrchr_P(const prog_void *, int __val, size_t __len) __attribute__((__const__));
extern char *strcat_P(char *, const prog_char *);
extern const prog_char * strchr_P(const prog_char *, int __val) __attribute__((__const__));
extern const prog_char * strchrnul_P(const prog_char *, int __val) __attribute__((__const__));
extern int strcmp_P(const char *, const prog_char *) __attribute__((__pure__));
extern char *strcpy_P(char *, const prog_char *);
extern int strcasecmp_P(const char *, const prog_char *) __attribute__((__pure__));
extern char *strcasestr_P(const char *, const prog_char *) __attribute__((__pure__));
extern size_t strcspn_P(const char *__s, const prog_char * __reject) __attribute__((__pure__));
extern size_t strlcat_P (char *, const prog_char *, size_t );
extern size_t strlcpy_P (char *, const prog_char *, size_t );
extern size_t strlen_P(const prog_char *) __attribute__((__const__));
extern size_t strnlen_P(const prog_char *, size_t) __attribute__((__const__));
extern int strncmp_P(const char *, const prog_char *, size_t) __attribute__((__pure__));
extern int strncasecmp_P(const char *, const prog_char *, size_t) __attribute__((__pure__));
extern char *strncat_P(char *, const prog_char *, size_t);
extern char *strncpy_P(char *, const prog_char *, size_t);
extern char *strpbrk_P(const char *__s, const prog_char * __accept) __attribute__((__pure__));
extern const prog_char * strrchr_P(const prog_char *, int __val) __attribute__((__const__));
extern char *strsep_P(char **__sp, const prog_char * __delim);
extern size_t strspn_P(const char *__s, const prog_char * __accept) __attribute__((__pure__));
extern char *strstr_P(const char *, const prog_char *) __attribute__((__pure__));


}
# 44 "../src/er9x.h" 2






# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/eeprom.h" 1 3
# 336 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/eeprom.h" 3
# 1 "/usr/lib/gcc/avr/4.3.4/include/stddef.h" 1 3 4
# 337 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/eeprom.h" 2 3
# 378 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/eeprom.h" 3
extern "C" {
# 423 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/eeprom.h" 3
uint8_t __eerd_byte_m64 (const uint8_t *__p) __attribute__((__pure__));




uint16_t __eerd_word_m64 (const uint16_t *__p) __attribute__((__pure__));




uint32_t __eerd_dword_m64 (const uint32_t *__p) __attribute__((__pure__));




float __eerd_float_m64 (const float *__p) __attribute__((__pure__));





void __eerd_block_m64 (void *__dst, const void *__src, size_t __n);





void __eewr_byte_m64 (uint8_t *__p, uint8_t __value);




void __eewr_word_m64 (uint16_t *__p, uint16_t __value);




void __eewr_dword_m64 (uint32_t *__p, uint32_t __value);




void __eewr_float_m64 (float *__p, float __value);





void __eewr_block_m64 (const void *__src, void *__dst, size_t __n);





void __eeupd_byte_m64 (uint8_t *__p, uint8_t __value);




void __eeupd_word_m64 (uint16_t *__p, uint16_t __value);




void __eeupd_dword_m64 (uint32_t *__p, uint32_t __value);




void __eeupd_float_m64 (float *__p, float __value);





void __eeupd_block_m64 (const void *__src, void *__dst, size_t __n);
# 527 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/eeprom.h" 3
}
# 51 "../src/er9x.h" 2
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/sleep.h" 1 3
# 52 "../src/er9x.h" 2
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/interrupt.h" 1 3
# 53 "../src/er9x.h" 2

# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h" 1 3
# 39 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h" 3
# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1 3
# 65 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 3
static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
# 80 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 3
void
_delay_loop_1(uint8_t __count)
{
 __asm__ volatile (
  "1: dec %0" "\n\t"
  "brne 1b"
  : "=r" (__count)
  : "0" (__count)
 );
}
# 102 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 3
void
_delay_loop_2(uint16_t __count)
{
 __asm__ volatile (
  "1: sbiw %0,1" "\n\t"
  "brne 1b"
  : "=w" (__count)
  : "0" (__count)
 );
}
# 40 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h" 2 3
# 79 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h" 3
static inline void _delay_us(double __us) __attribute__((always_inline));
static inline void _delay_ms(double __ms) __attribute__((always_inline));
# 109 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h" 3
void
_delay_ms(double __ms)
{
 uint16_t __ticks;
 double __tmp = ((16000000UL) / 4e3) * __ms;
 if (__tmp < 1.0)
  __ticks = 1;
 else if (__tmp > 65535)
 {

  __ticks = (uint16_t) (__ms * 10.0);
  while(__ticks)
  {

   _delay_loop_2(((16000000UL) / 4e3) / 10);
   __ticks --;
  }
  return;
 }
 else
  __ticks = (uint16_t)__tmp;
 _delay_loop_2(__ticks);
}
# 147 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h" 3
void
_delay_us(double __us)
{
 uint8_t __ticks;
 double __tmp = ((16000000UL) / 3e6) * __us;
 if (__tmp < 1.0)
  __ticks = 1;
 else if (__tmp > 255)
 {
  _delay_ms(__us / 1000.0);
  return;
 }
 else
  __ticks = (uint8_t)__tmp;
 _delay_loop_1(__ticks);
}
# 55 "../src/er9x.h" 2

# 1 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/wdt.h" 1 3
# 57 "../src/er9x.h" 2



# 1 "../src/file.h" 1
# 26 "../src/file.h"
bool EeFsOpen();
int8_t EeFsck();
void EeFsFormat();
uint16_t EeFsGetFree();



class EFile
{
  uint8_t m_fileId;
  uint16_t m_pos;
  uint8_t m_currBlk;
  uint8_t m_ofs;
  uint8_t m_bRlc;
  uint8_t m_err;
  uint16_t m_stopTime10ms;
public:

  static void rm(uint8_t i_fileId);


  static void swap(uint8_t i_fileId1,uint8_t i_fileId2);


  static bool exists(uint8_t i_fileId);



  uint8_t openRd(uint8_t i_fileId);




  void create(uint8_t i_fileId, uint8_t typ, uint8_t maxTme10ms);

  void closeTrunc();




  uint16_t writeRlc(uint8_t i_fileId, uint8_t typ,uint8_t*buf,uint16_t i_len, uint8_t maxTme10ms);

  uint8_t read(uint8_t*buf,uint8_t i_len);
  uint8_t write(uint8_t*buf,uint8_t i_len);


  uint16_t size();

  uint16_t readRlc(uint8_t*buf,uint16_t i_len);

  uint8_t errno(){return m_err;}
};
# 61 "../src/er9x.h" 2
# 143 "../src/er9x.h"
enum EnumKeys {
  KEY_MENU ,
  KEY_EXIT ,
  KEY_DOWN ,
  KEY_UP ,
  KEY_RIGHT ,
  KEY_LEFT ,
  TRM_LH_DWN ,
  TRM_LH_UP ,
  TRM_LV_DWN ,
  TRM_LV_UP ,
  TRM_RV_DWN ,
  TRM_RV_UP ,
  TRM_RH_DWN ,
  TRM_RH_UP ,


  SW_ThrCt ,
  SW_RuddDR ,
  SW_ElevDR ,
  SW_ID0 ,
  SW_ID1 ,
  SW_ID2 ,
  SW_AileDR ,
  SW_Gear ,
  SW_Trainer
};
# 210 "../src/er9x.h"
typedef void (*MenuFuncP)(uint8_t event);


void pauseEvents(uint8_t enuk);

uint8_t getEventDbl(uint8_t event);

void killEvents(uint8_t enuk);

bool keyState(EnumKeys enuk);



uint8_t getEvent();


void chainMenu(MenuFuncP newMenu);

void pushMenu(MenuFuncP newMenu);

MenuFuncP lastPopMenu();


void popMenu(bool uppermost=false);


void alert(const prog_char * s);

void perMain();


void per10ms();

void perOut(int16_t *chanOut);
# 254 "../src/er9x.h"
bool getSwitch(int8_t swtch, bool nc);






void putsDrSwitches(uint8_t x,uint8_t y,int8_t swtch,uint8_t att);

void checkMem();
void checkTHR();

void checkSwitches();
# 277 "../src/er9x.h"
bool checkIncDecGen2(uint8_t event, void *i_pval, int16_t i_min, int16_t i_max, uint8_t i_flags);


template<int16_t min,int16_t max>
bool checkIncDecModVar(uint8_t event, void*p, uint8_t flags)
{
  return checkIncDecGen2(event, p, min, max, flags);
}



int8_t checkIncDec_hm(uint8_t event, int8_t i_val, int8_t i_min, int8_t i_max);

int8_t checkIncDec_vm(uint8_t event, int8_t i_val, int8_t i_min, int8_t i_max);

int8_t checkIncDec_hg(uint8_t event, int8_t i_val, int8_t i_min, int8_t i_max);

int8_t checkIncDec_vg(uint8_t event, int8_t i_val, int8_t i_min, int8_t i_max);

extern bool checkIncDec_Ret;
# 332 "../src/er9x.h"
template<class t> inline t abs(t a){ return a>0?a:-a; }

template<class t> inline t min(t a, t b){ return a<b?a:b; }

template<class t> inline t max(t a, t b){ return a>b?a:b; }
template<class t> inline int8_t sgn(t a){ return a>0 ? 1 : (a < 0 ? -1 : 0); }






void eeWriteBlockCmp(const void *i_pointer_ram, void *i_pointer_eeprom, size_t size);
void eeDirty(uint8_t msk);
void eeCheck(bool immediately=false);

void eeReadAll();
void eeLoadModelName(uint8_t id,char*buf,uint8_t len);
void eeLoadModel(uint8_t id);

bool eeDuplicateModel(uint8_t id);
# 364 "../src/er9x.h"
void putsChnRaw(uint8_t x,uint8_t y,uint8_t idx1,uint8_t att);



void putsChn(uint8_t x,uint8_t y,uint8_t idx1,uint8_t att);

void putsVBat(uint8_t x,uint8_t y,uint8_t att);
void putsTime(uint8_t x,uint8_t y,int16_t tme,uint8_t att,uint8_t att2);






void menuProcLimits(uint8_t event);
void menuProcMixOne(uint8_t event);
void menuProcMix(uint8_t event);
void menuProcCurve(uint8_t event);
void menuProcTrim(uint8_t event);
void menuProcExpoOne(uint8_t event);
void menuProcExpoAll(uint8_t event);
void menuProcModel(uint8_t event);
void menuProcDiagCalib(uint8_t event);
void menuProcDiagAna(uint8_t event);
void menuProcDiagKeys(uint8_t event);
void menuProcDiagVers(uint8_t event);
void menuProcTrainer(uint8_t event);
void menuProcSetup0(uint8_t event);
void menuProcSetup1(uint8_t event);
void menuProcMain(uint8_t event);
void menuProcModelSelect(uint8_t event);

void menuProcStatistic2(uint8_t event);
void menuProcStatistic(uint8_t event);
void menuProc0(uint8_t event);

void setupPulses();
void setupPulsesPPM();
void setupPulsesSilver();
void setupPulsesTracerCtp1009();

extern int16_t intpol(int16_t, uint8_t);


extern uint16_t anaIn(uint8_t chan);






extern uint8_t g_vbat100mV;
extern volatile uint16_t g_tmr10ms;
extern volatile uint8_t g_blinkTmr10ms;
extern uint8_t g_beepCnt;
extern uint8_t g_beepVal[4];
extern const __attribute__((__progmem__)) char modi12x3[];

extern uint16_t pulses2MHz[60];
extern int16_t g_ppmIns[8];
extern int16_t g_chans512[16];

# 1 "../src/lcd.h" 1
# 18 "../src/lcd.h"
# 1 "../src/er9x.h" 1
# 19 "../src/lcd.h" 2
# 45 "../src/lcd.h"
extern unsigned char displayBuf[128*64/8];

extern void lcd_putcAtt(unsigned char x,unsigned char y,const char c,uint8_t mode);
extern unsigned char lcd_putsAtt(unsigned char x,unsigned char y,const prog_char * s,uint8_t mode);
extern void lcd_putsnAtt(unsigned char x,unsigned char y,const prog_char * s,unsigned char len,uint8_t mode);

extern void lcd_putc(unsigned char x,unsigned char y,const char c);
extern void lcd_puts_P(unsigned char x,unsigned char y,const prog_char * s);
extern void lcd_putsn_P(unsigned char x,unsigned char y,const prog_char * s,unsigned char len);
extern void lcd_outhex4(unsigned char x,unsigned char y,uint16_t val);
extern void lcd_outdezAtt(unsigned char x,unsigned char y,int16_t val,uint8_t mode);
void lcd_outdezNAtt(uint8_t x,uint8_t y,int16_t val,uint8_t mode,uint8_t len);

extern void lcd_outdez(unsigned char x,unsigned char y,int16_t val);

extern void lcd_plot(unsigned char x,unsigned char y);
extern void lcd_hline(unsigned char x,unsigned char y, signed char w);
extern void lcd_hlineStip(unsigned char x,unsigned char y, signed char w,uint8_t pat);
extern void lcd_vline(unsigned char x,unsigned char y, signed char h);

extern void lcd_img_f(unsigned char x,unsigned char y);
extern void lcd_img(uint8_t i_x,uint8_t i_y,const prog_uchar * imgdat,uint8_t idx,uint8_t mode);

extern void lcd_init();
extern void lcd_clear();
extern void refreshDiplay();
extern void lcdSetRefVolt(unsigned char val);
# 427 "../src/er9x.h" 2
extern const char stamp1[];
extern const char stamp2[];
extern const char stamp3[];
extern const char stamp4[];
# 1 "../src/myeeprom.h" 1
# 29 "../src/myeeprom.h"
typedef struct t_TrainerData1 {
  uint8_t srcChn:3;
  int8_t swtch:5;
  int8_t studWeight:6;
  uint8_t mode:2;
} __attribute__((packed)) TrainerData1;

typedef struct t_TrainerData {
  int16_t calib[4];
  TrainerData1 chanMix[4];
} __attribute__((packed)) TrainerData;


typedef struct t_EEGeneral {
  uint8_t myVers;
  int16_t calibMid[4];
  int16_t calibSpanNeg[4];
  int16_t calibSpanPos[4];
  uint16_t chkSum;
  uint8_t currModel;
  uint8_t contrast;
  uint8_t vBatWarn;
  int8_t vBatCalib;
  int8_t lightSw;
  TrainerData trainer;
  uint8_t view;




  uint8_t warnOpts;
  uint8_t stickMode;
} __attribute__((packed)) EEGeneral;
# 71 "../src/myeeprom.h"
typedef struct t_ExpoData {
  int8_t expNorm;
  int8_t expDr;
  int8_t drSw;
  int8_t expNormWeight;
  int8_t expSwWeight;
} __attribute__((packed)) ExpoData;

typedef struct t_TrimData {
  int8_t trim;
  int16_t trimDef;
} __attribute__((packed)) TrimData;

typedef struct t_LimitData {
  int8_t min;
  int8_t max;
  bool revert;
  int16_t offset;
} __attribute__((packed)) LimitData;


typedef struct t_MixData {
  uint8_t destCh;
  uint8_t srcRaw:7;
  uint8_t carryTrim:1;
  int8_t weight;
  int8_t swtch;
  uint8_t curve;
  uint8_t speedUp:4;
  uint8_t speedDown:4;
} __attribute__((packed)) MixData;


typedef struct t_ModelData {
  char name[10];
  uint8_t mdVers;
  uint8_t tmrMode;
  uint16_t tmrVal;
  uint8_t protocol;
  uint8_t ppmNCH;
  char res[2];
  int8_t thrTrim;
  int8_t trimInc;
  int8_t tcutSW;
  MixData mixData[25];
  TrimData trimData[4];
  LimitData limitData[16];
  ExpoData expoData[4];
  int8_t curves5[8][5];
  int8_t curves9[8][9];



} __attribute__((packed)) ModelData;





extern EEGeneral g_eeGeneral;
extern ModelData g_model;
# 432 "../src/er9x.h" 2


inline void _beep(uint8_t b) {
  g_beepCnt=b;



}
# 18 "../src/menus.cpp" 2





static int16_t anaCalib[4];
int16_t g_chans512[16];



# 1 "../src/sticks.lbm" 1
prog_uchar __attribute__(( section(".progmem.data") )) sticks[] = {
18,8,18,
0x00,0x08,0x1c,0x08,0x08,0x08,0x1c,0x08,0x00,0x00,0x08,0x22,0x00,0x49,0x00,0x22,0x08,0x00,
0x00,0x00,0x00,0x00,0x22,0x7f,0x22,0x00,0x00,0x00,0x08,0x22,0x00,0x49,0x00,0x22,0x08,0x00,
0x00,0x08,0x22,0x00,0x49,0x00,0x22,0x08,0x00,0x00,0x00,0x22,0x7f,0x22,0x00,0x00,0x00,0x00,
0x00,0x08,0x22,0x00,0x49,0x00,0x22,0x08,0x00,0x00,0x08,0x1c,0x08,0x08,0x08,0x1c,0x08,0x00,
};
# 29 "../src/menus.cpp" 2
typedef __attribute__((__progmem__)) void (*MenuFuncP_PROGMEM)(uint8_t event);

MenuFuncP_PROGMEM __attribute__(( section(".progmem.data") )) menuTabModel[] = {
  menuProcModelSelect,
  menuProcModel,
  menuProcExpoAll,
  menuProcMix,
  menuProcTrim,
  menuProcLimits,
  menuProcCurve
};

MenuFuncP_PROGMEM __attribute__(( section(".progmem.data") )) menuTabDiag[] = {
  menuProcSetup0,
  menuProcSetup1,
  menuProcTrainer,
  menuProcDiagVers,
  menuProcDiagKeys,
  menuProcDiagAna,
  menuProcDiagCalib
};


struct MState2
{
  uint8_t m_posVert;
  uint8_t m_posHorz;
  void init(){m_posVert=m_posHorz=0;};
  prog_uint8_t *m_tab;
  static uint8_t event;
  void check_v(uint8_t event, uint8_t curr,MenuFuncP *menuTab, uint8_t menuTabSize, uint8_t maxrow);
  void check(uint8_t event, uint8_t curr,MenuFuncP *menuTab, uint8_t menuTabSize, prog_uint8_t*subTab,uint8_t subTabMax,uint8_t maxrow);
};







void MState2::check_v(uint8_t event, uint8_t curr,MenuFuncP *menuTab, uint8_t menuTabSize, uint8_t maxrow)
{
  check( event, curr, menuTab, menuTabSize, 0, 0, maxrow);
}
void MState2::check(uint8_t event, uint8_t curr,MenuFuncP *menuTab, uint8_t menuTabSize, prog_uint8_t*horTab,uint8_t horTabMax,uint8_t maxrow)
{
  if(menuTab){
    uint8_t attr = 0x01;
    curr--;

    if(m_posVert==0){
      attr = 0x02;
      switch(event)
      {
        case ((KEY_LEFT)| 0x40|0x20):
          if(curr>0){
            chainMenu((MenuFuncP)(__extension__({ uint16_t __addr16 = (uint16_t)((uint16_t)(&menuTab[curr-1])); uint16_t __result; __asm__ ( "lpm %A0, Z+" "\n\t" "lpm %B0, Z" "\n\t" : "=r" (__result), "=z" (__addr16) : "1" (__addr16) ); __result; })));
          }
          break;
        case ((KEY_RIGHT)| 0x40|0x20):
          if(curr < (menuTabSize-1)){
            chainMenu((MenuFuncP)(__extension__({ uint16_t __addr16 = (uint16_t)((uint16_t)(&menuTab[curr+1])); uint16_t __result; __asm__ ( "lpm %A0, Z+" "\n\t" "lpm %B0, Z" "\n\t" : "=r" (__result), "=z" (__addr16) : "1" (__addr16) ); __result; })));
          }
          break;
      }
    }
    lcd_putcAtt(128-6*1,0,menuTabSize+'0',attr);
    lcd_putcAtt(128-6*2,0,'/',attr);
    lcd_putcAtt(128-6*3,0,curr+'1',attr);
  }




  uint8_t maxcol = (horTab ? (__extension__({ uint16_t __addr16 = (uint16_t)((uint16_t)(horTab+min( m_posVert, horTabMax ))); uint8_t __result; __asm__ ( "lpm %0, Z" "\n\t" : "=r" (__result) : "z" (__addr16) ); __result; }))-1 : 0);
  switch(event)
  {
    case (0xff - 0x40):

        m_posVert=0;

      break;
    case ((KEY_EXIT)|0x80):
      popMenu(true);
      break;
    case ((KEY_EXIT)| 0x20):
      if(m_posVert==0 || !menuTab) {
        popMenu();
      } else {
        _beep(g_beepVal[0]);
        init();g_blinkTmr10ms = (3<<5);
      }
      break;
    case ((KEY_DOWN)| 0x20):
      if(!horTab)break;
      if(m_posVert<maxrow) {m_posVert++;} else {m_posVert=0;};
      m_posHorz=min(m_posHorz,maxcol);
      g_blinkTmr10ms = (3<<5);
      break;
    case ((KEY_DOWN)|0x80):
      if(!horTab)break;
      killEvents(event);
      if(m_posHorz<maxcol) {m_posHorz++;} else {m_posHorz=0;};
      g_blinkTmr10ms = (3<<5);
      break;

    case ((KEY_DOWN)| 0x40 ):
      if(m_posVert==maxrow) break;
    case ((KEY_DOWN)| 0x40|0x20):
      if(horTab)break;
      if(m_posVert<maxrow) {m_posVert++;} else {m_posVert=0;};
      g_blinkTmr10ms = (3<<5);
      break;

    case ((KEY_UP)| 0x20):
      if(!horTab)break;
      if(m_posVert>0 ) {m_posVert--;} else {m_posVert=maxrow;};
      m_posHorz=min(m_posHorz,maxcol);
      g_blinkTmr10ms = (3<<5);
      break;
    case ((KEY_UP)|0x80):
      if(!horTab)break;
      killEvents(event);
      if(m_posHorz>0 ) {m_posHorz--;} else {m_posHorz=maxcol;};
      g_blinkTmr10ms = (3<<5);
      break;

    case ((KEY_UP)| 0x40 ):
      if(m_posVert==0) break;
    case ((KEY_UP)| 0x40|0x20):
      if(horTab)break;
      if(m_posVert>0 ) {m_posVert--;} else {m_posVert=maxrow;};
      g_blinkTmr10ms = (3<<5);
      break;

  }
}
# 179 "../src/menus.cpp"
static uint8_t s_curveChan;

void menuProcCurveOne(uint8_t event) {
  static MState2 mstate2;
  uint8_t x = lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("CURVE ");&__c[0];})),0x01);
  lcd_outdezAtt(x, 0,s_curveChan+1 ,0x01);

  bool cv9 = s_curveChan >= 8;
  mstate2.check_v(event,0,0,0,(cv9 ? 9 : 5)+1 -1);
  int8_t sub = mstate2.m_posVert;

  int8_t *crv = cv9 ? g_model.curves9[s_curveChan-8] : g_model.curves5[s_curveChan];

    for (uint8_t i = 0; i < 5; i++) {
      uint8_t y = i * 8 + 16;
      uint8_t attr = sub == i ? 0x02 : 0;
      lcd_outdezAtt(4 * 6, y, crv[i], attr);
    }
  if(cv9)
    for (uint8_t i = 0; i < 4; i++) {
      uint8_t y = i * 8 + 16;
      uint8_t attr = sub == i + 5 ? 0x02 : 0;
      lcd_outdezAtt(8 * 6, y, crv[i + 5], attr);
    }
  lcd_putsAtt( 2*6, 7*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("PRESET");&__c[0];})),sub == (cv9 ? 9 : 5) ? 0x02 : 0);

  static int8_t dfltCrv;
  if(sub<(cv9 ? 9 : 5)) checkIncDecModVar<-100,100>(event,&crv[sub],(sizeof(crv[sub])==2 ? 4 : 0)|2);
  else {
    if( checkIncDecGen2(event, &dfltCrv, -4, 4, 0)){
      if(cv9) for (uint8_t i = 0; i < 9; i++) crv[i] = (i-4)*dfltCrv* 100 / 16;
      else for (uint8_t i = 0; i < 5; i++) crv[i] = (i-2)*dfltCrv* 100 / 8;
      eeDirty(2);
    }
  }
# 223 "../src/menus.cpp"
  for (uint8_t xv = 0; xv < 32 * 2; xv++) {
    uint16_t yv = intpol(xv * (512u / 32) - 512u, s_curveChan) / (512u
                                                                      / 32);
    lcd_plot((128-32 -2) + xv - 32, 32 - yv);
    if ((xv & 3) == 0) {
      lcd_plot((128-32 -2) + xv - 32, 32 + 0);
    }
  }
  lcd_vline((128-32 -2), 32 - 32, 32 * 2);
}

void menuProcCurve(uint8_t event) {
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("CURVE");&__c[0];})),0x01);
  mstate2.check_v(event,7,menuTabModel,(sizeof((menuTabModel))/sizeof((menuTabModel)[0])),8 +8 +1 -1);
  int8_t sub = mstate2.m_posVert - 1;

  static uint8_t s_pgOfs;
  if(sub<1) s_pgOfs=0;
  else if((sub-s_pgOfs)>6) s_pgOfs = sub-6;
  else if((sub-s_pgOfs)<0) s_pgOfs = sub;
  if(s_pgOfs<0) s_pgOfs = 0;

  switch (event) {
    case (0xff - 0x40):
      s_pgOfs = 0;
      break;
    case ((KEY_MENU)| 0x40|0x20):
      if (sub >= 0) {
        s_curveChan = sub;
        pushMenu(menuProcCurveOne);
      }
      break;
  }

  uint8_t y = 1*8;
  uint8_t yd = 1;
  uint8_t m = 0;
  for (uint8_t i = 0; i < 7; i++) {
    uint8_t k = i + s_pgOfs;
    uint8_t attr = sub == k ? 0x02 : 0;
    bool cv9 = k >= 8;

    if(cv9 && (yd>6)) break;
    if(yd>7) break;
    if(!m) m = attr;
    lcd_putsAtt( 6*0, y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("CV");&__c[0];})),attr);
    lcd_outdezAtt( (k<9) ? 6*3 : 6*4-1, y,k+1 ,attr);

    int8_t *crv = cv9 ? g_model.curves9[k-8] : g_model.curves5[k];
    for (uint8_t j = 0; j < (5); j++) {
      lcd_outdezAtt( j*(3*6 +3) + 7*6, y, crv[j], 0);
    }
    y += 8;yd++;
    if(cv9){
      for (uint8_t j = 0; j < 4; j++) {
        lcd_outdezAtt( j*(3*6 +3) + 7*6, y, crv[j+5], 0);
      }
      y += 8;yd++;
    }
  }

  if(!m) s_pgOfs++;
}



static bool s_limitCacheOk;


void menuProcLimits(uint8_t event)
{
  static MState2 mstate2;
  static bool swVal[16];
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("LIMITS");&__c[0];})),0x01);
  static prog_uint8_t __attribute__(( section(".progmem.data") )) mstate_tab[] = { 4,4};
  mstate2.check(event,6,menuTabModel,(sizeof((menuTabModel))/sizeof((menuTabModel)[0])),mstate_tab,(sizeof((mstate_tab))/sizeof((mstate_tab)[0]))-1,(8+g_model.ppmNCH*2)+1 -1);

  int8_t sub = mstate2.m_posVert - 1;
  uint8_t subSub = mstate2.m_posHorz + 1;
  static uint8_t s_pgOfs;
  if(sub<1) s_pgOfs=0;
  else if((sub-s_pgOfs)>5) s_pgOfs = sub-5;
  else if((sub-s_pgOfs)<0) s_pgOfs = sub;
  if(s_pgOfs<0) s_pgOfs = 0;

  switch(event)
  {
    case (0xff - 0x40):
      s_pgOfs = 0;
      break;
    case ((KEY_MENU)| 0x40|0x20):



      int16_t v = g_chans512[sub - s_pgOfs];
      LimitData *ld = &g_model.limitData[sub - s_pgOfs];
      switch (subSub)
      {
        case 1:
      ld->offset = (ld->revert) ? -v : v;
      s_limitCacheOk=false;
      break;
    case 2:



      break;
      }
      break;
  }
  lcd_puts_P( 4*6, 1*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("subT min  max inv");&__c[0];})));
  for(uint8_t i=0; i<6; i++){
    uint8_t y=(i+2)*8;
    uint8_t k=i+s_pgOfs;

    LimitData *ld = &g_model.limitData[k];
    for(uint8_t j=0; j<=4;j++){
      uint8_t attr = ((sub==k && subSub==j) ? 0x02 : 0);

      int16_t v = (ld->revert) ? -ld->offset : ld->offset;
      if((g_chans512[k] - v) > 25) swVal[k] = (true==ld->revert);
      if((g_chans512[k] - v) < -25) swVal[k] = (false==ld->revert);


      switch(j)
      {
        case 0:
          putsChn(0,y,k+1,(sub==k && subSub==0) ? 0x01 : 0);
          break;
        case 1:
          lcd_outdezAtt( 7*6, y, ld->offset, attr);
          if(attr) {
            if(checkIncDecModVar<-500,500>(event,&ld->offset,(sizeof(ld->offset)==2 ? 4 : 0)|2)) s_limitCacheOk=false;
          }
          break;
        case 2:
          lcd_outdezAtt( 12*6, y, (int8_t)(ld->min-100), attr);
          if(attr) {
            ld->min -= 100;
            if(checkIncDecModVar<-125,125>(event,&ld->min,(sizeof(ld->min)==2 ? 4 : 0)|2)) s_limitCacheOk=false;
            ld->min += 100;
          }
          break;
        case 3:
          lcd_outdezAtt( 17*6, y, (int8_t)(ld->max+100), attr);
          if(attr) {
            ld->max += 100;
            if(checkIncDecModVar<-125,125>(event,&ld->max,(sizeof(ld->max)==2 ? 4 : 0)|2)) s_limitCacheOk=false;
            ld->max -= 100;
          }
          break;
        case 4:
          lcd_putsnAtt( 18*6, y, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = (" - INV");&__c[0];}))+ld->revert*3,3,attr);
          if(attr) {
            ( ld->revert=checkIncDec_hm(event,ld->revert,0,1), checkIncDec_Ret );
          }
          break;
      }
    }
  }
}



static int8_t s_currMixIdx;
static int8_t s_currDestCh;
static bool s_currMixInsMode;
void menuProcMixOne(uint8_t event)
{
  static MState2 mstate2;
  uint8_t x=lcd_putsAtt(0,0,s_currMixInsMode ? (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("INSERT MIX ");&__c[0];})) : (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("EDIT MIX ");&__c[0];})),0x01);
  MixData *md2 = &g_model.mixData[s_currMixIdx];

  putsChn(x+1*6,0,md2->destCh,0);
  mstate2.check_v(event,0,0,0,8 -1);
  int8_t sub = mstate2.m_posVert;



  for(uint8_t i=0; i<=7; i++)
  {
    uint8_t y=i*8 +8;
    uint8_t attr = sub==i ? 0x02 : 0;
    lcd_putsn_P( 6*2, y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("SourceWeightTrim  CurvesSwitchFade            ");&__c[0];}))+6*i,6);
    switch(i){
      case 0: putsChnRaw( 6*9,y,md2->srcRaw,attr);

        if(attr) ( md2->srcRaw=checkIncDec_hm(event,md2->srcRaw,1,(16 +9+0)), checkIncDec_Ret );
        break;
      case 1: lcd_outdezAtt(6*11 + 6/2,y,md2->weight,attr);
        if(attr) checkIncDecModVar<-125,125>(event,&md2->weight,(sizeof(md2->weight)==2 ? 4 : 0)|2);
        break;
      case 2:
        lcd_putsnAtt(6*9,y, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("ON OFF");&__c[0];}))+3*md2->carryTrim,3,attr);
        if(attr) ( md2->carryTrim=checkIncDec_hm(event,md2->carryTrim,0,1), checkIncDec_Ret );
        break;
      case 3: lcd_putsnAtt( 6*9,y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = (" - x>0x<0|x|c1 c2 c3 c4 c5 c6 c7 c8 c9 c10c11c12c13c14c15c16c18c19c20");&__c[0];}))+md2->curve*3,3,attr);
        if(attr) checkIncDecModVar<0,8 +8 +4-1>(event,&md2->curve,(sizeof(md2->curve)==2 ? 4 : 0)|2);
        if(attr && md2->curve>=4 && event==((KEY_MENU)| 0x40|0x20)){
          s_curveChan = md2->curve-4;
          pushMenu(menuProcCurveOne);
        }
        break;
      case 4: putsDrSwitches(8*6, y,md2->swtch,attr);
        if(attr) checkIncDecModVar<-(1+SW_Trainer-SW_ThrCt+1),(1+SW_Trainer-SW_ThrCt+1)>(event,&md2->swtch,(sizeof(md2->swtch)==2 ? 4 : 0)|2);
        break;
      case 5: lcd_putcAtt(9*6, y, '<',0);
        lcd_outdezAtt(6*12,y,md2->speedDown,attr);
        if(attr) ( md2->speedDown=checkIncDec_hm(event,md2->speedDown,0,15), checkIncDec_Ret );
        break;
      case 6: lcd_putcAtt(13*6, y-8, '>',0);
        lcd_outdezAtt(6*16,y-8,md2->speedUp,attr);
        if(attr) ( md2->speedUp=checkIncDec_hm(event,md2->speedUp,0,15), checkIncDec_Ret );
        break;
      case 7: lcd_putsAtt( 6*3,y-8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("RM");&__c[0];})),attr);
                lcd_puts_P( 6*6,y-8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("remove [Menu]");&__c[0];})));
        if(attr && event==((KEY_MENU)| 0x40|0x20)){
          memmove(
            &g_model.mixData[s_currMixIdx],
            &g_model.mixData[s_currMixIdx+1],
            (25 -(s_currMixIdx+1))*sizeof(MixData));
          memset(&g_model.mixData[25 -1],0,sizeof(MixData));
          eeDirty(2);
          popMenu();
        }
        break;
    }
  }
}
# 464 "../src/menus.cpp"
struct MixTab{
  bool showCh:1;
  bool hasDat:1;
  int8_t chId;
  int8_t selCh;
  int8_t selDat;
  int8_t insIdx;
  int8_t editIdx;
} s_mixTab[25 +(16 +0)+1];
int8_t s_mixMaxSel;

void genMixTab()
{
  uint8_t maxDst = 0;
  uint8_t mtIdx = 0;
  uint8_t sel = 1;
  memset(s_mixTab,0,sizeof(s_mixTab));

  MixData *md=g_model.mixData;

  for(uint8_t i=0; i<25; i++)
  {
    uint8_t destCh = md[i].destCh;
    if(destCh==0) destCh=(16 +0);
    if(destCh > maxDst){
      while(destCh > maxDst){
        maxDst++;
        s_mixTab[mtIdx].chId = maxDst;
        s_mixTab[mtIdx].showCh = true;
        s_mixTab[mtIdx].selCh = sel++;
        s_mixTab[mtIdx].insIdx= i;
        mtIdx++;
      }
      mtIdx--;
      s_mixMaxSel =sel;
      sel--;
    }
    if(md[i].destCh==0) break;
    s_mixTab[mtIdx].chId = destCh;
    s_mixTab[mtIdx].editIdx = i;
    s_mixTab[mtIdx].hasDat = true;
    s_mixTab[mtIdx].selDat = sel++;
    if(md[i].destCh == md[i+1].destCh){
      s_mixTab[mtIdx].selCh = 0;
      s_mixTab[mtIdx].insIdx = 0;
    }
    else{
      s_mixTab[mtIdx].selCh = sel++;
      s_mixTab[mtIdx].insIdx = i+1;
    }
    s_mixMaxSel =sel;
    mtIdx++;
  }
}

void menuProcMix(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("MIXER");&__c[0];})),0x01);
  mstate2.check_v(event,4,menuTabModel,(sizeof((menuTabModel))/sizeof((menuTabModel)[0])),s_mixMaxSel-1);
  int8_t sub = mstate2.m_posVert;

  static uint8_t s_pgOfs;
  MixData *md=g_model.mixData;
  switch(event)
  {
    case (0xff - 0x40):
      s_pgOfs=0;
    case (0xfe - 0x40):
      genMixTab();
      break;
    case ((KEY_MENU)| 0x40|0x20):
      if(sub<1) break;

      if(s_currMixInsMode) {
        memmove(&md[s_currMixIdx+1],&md[s_currMixIdx],
                (25 -(s_currMixIdx+1))*sizeof(md[0]) );
        md[s_currMixIdx].destCh = s_currDestCh;
        md[s_currMixIdx].srcRaw = s_currDestCh;
        md[s_currMixIdx].weight = 100;
        md[s_currMixIdx].swtch = 0;
        md[s_currMixIdx].curve = 0;
        md[s_currMixIdx].speedUp = 0;
        md[s_currMixIdx].speedDown = 0;
        eeDirty(2);
      }
      pushMenu(menuProcMixOne);
      break;
  }

  int8_t markedIdx=-1;
  uint8_t i;
  int8_t minSel=99;
  int8_t maxSel=-1;
  lcd_puts_P( 6*6, 1*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("wt src  sw crv");&__c[0];})));
  for(i=0; i<6; i++){
    uint8_t y = i * 8 + 2*8;
    uint8_t k = i + s_pgOfs;
    if(!s_mixTab[k].showCh && !s_mixTab[k].hasDat ) break;

    if(s_mixTab[k].showCh){
      putsChn(0,y,s_mixTab[k].chId,0);
    }
    if(sub>0 && sub==s_mixTab[k].selCh) {
      if((g_blinkTmr10ms & (1<<6))) lcd_hline(0,y+7,6*4);
      s_currMixIdx = s_mixTab[k].insIdx;
      s_currDestCh = s_mixTab[k].chId;
      s_currMixInsMode = true;
      markedIdx = i;
    }
    if(s_mixTab[k].hasDat){
      MixData *md2=&md[s_mixTab[k].editIdx];
      uint8_t attr = sub==s_mixTab[k].selDat ? 0x02 : 0;
      lcd_outdezAtt( 7*6 +6/2, y, md2->weight,attr);
      lcd_putcAtt( 7*6 +6/2, y, '%',0);
      putsChnRaw( 9*6, y, md2->srcRaw,0);

      if(md2->swtch)putsDrSwitches( 13*6, y, md2->swtch,0);
      if(md2->curve)lcd_putsnAtt( 17*6, y, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = (" - x>0x<0|x|c1 c2 c3 c4 c5 c6 c7 c8 c9 c10c11c12c13c14c15c16c18c19c20");&__c[0];}))+md2->curve*3,3,0);
      if(md2->speedDown || md2->speedUp)lcd_putcAtt(20*6 +1, y, 's',0);
      if(attr == 0x02){
        checkIncDecModVar<-125,125>(event,&md2->weight,(sizeof(md2->weight)==2 ? 4 : 0)|2);
        s_currMixIdx = s_mixTab[k].editIdx;
        s_currDestCh = s_mixTab[k].chId;
        s_currMixInsMode = false;
        markedIdx = i;

      }
    }

    if(s_mixTab[k].selCh){
      minSel = min(minSel,s_mixTab[k].selCh);
      maxSel = max(maxSel,s_mixTab[k].selCh);
    }
    if(s_mixTab[k].selDat){
      minSel = min(minSel,s_mixTab[k].selDat);
      maxSel = max(maxSel,s_mixTab[k].selDat);
    }

  }
  if( sub!=0 && markedIdx==-1) {
    if(sub < minSel) s_pgOfs = max(0,s_pgOfs-1);
    if(sub > maxSel) s_pgOfs++;
  }
  else if(markedIdx<=1) s_pgOfs = max(0,s_pgOfs-1);
  else if(markedIdx>=5 && i>=7) s_pgOfs++;

}


void menuProcTrim(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("TRIM");&__c[0];})),0x01);
  mstate2.check_v(event,5,menuTabModel,(sizeof((menuTabModel))/sizeof((menuTabModel)[0])),4+1 -1);
  int8_t sub = mstate2.m_posVert - 1;

  switch(event)
  {
    case ((KEY_LEFT)| 0x40|0x20):
    case ((KEY_LEFT)| 0x40 ):
      if(sub>=0)
      {
        g_model.trimData[sub].trimDef = 0;
        eeDirty(2);
        _beep(g_beepVal[0]);
      }
      break;
    case ((KEY_RIGHT)| 0x40|0x20):
    case ((KEY_RIGHT)| 0x40 ):
      if(sub>=0)
      {
    int16_t x = g_model.trimData[sub].trimDef + g_model.trimData[sub].trim;
    if(x>512) x=512;
    if(x<-512) x=-512;
        g_model.trimData[sub].trimDef = x;
        g_model.trimData[sub].trim = 0;
        eeDirty(2);
        _beep(g_beepVal[0]);
      }
      break;
  }
  lcd_puts_P( 6*6, 1*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Trim  Base");&__c[0];})));
  for(uint8_t i=0; i<4; i++)
  {
    uint8_t y=i*8 +16;
    uint8_t attr = sub==i ? 0x02 : 0;
    putsChnRaw(0,y,i+1,0);
    lcd_outdezAtt( 8*6, y, g_model.trimData[i].trim, attr );
    lcd_outdezAtt(14*6, y, g_model.trimData[i].trimDef, attr );
  }
  lcd_puts_P(0,8*7,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = (" -> Balance  <- Clr");&__c[0];})));
}


uint16_t expou(uint16_t x, uint16_t k)
{

  return ((unsigned long)x*x*x/0x10000*k/(512ul*512ul/0x10000) + (100ul -k)*x+100ul/2)/100ul;
}
# 672 "../src/menus.cpp"
int16_t expo(int16_t x, int16_t k)
{
  if(k == 0) return x;
  int16_t y;
  bool neg = x < 0;
  if(neg) x = -x;
  if(k<0){
    y = 512u -expou(512u -x,-k);
  }else{
    y = expou(x,k);
  }
  return neg? -y:y;
}
# 723 "../src/menus.cpp"
static uint8_t s_expoChan;

void editExpoVals(uint8_t event,uint8_t which,bool edit,uint8_t x, uint8_t y, uint8_t chn)
{
  uint8_t invBlk = edit ? 0x02 : 0;
  switch(which)
  {
    case 0:
      lcd_outdezAtt(x, y, g_model.expoData[chn].expNorm, invBlk);
      if(edit) checkIncDecModVar<-100,100>(event,&g_model.expoData[chn].expNorm,(sizeof(g_model.expoData[chn].expNorm)==2 ? 4 : 0)|2);
      break;
    case 1:
      lcd_outdezAtt(x, y, g_model.expoData[chn].expNormWeight+100, invBlk);
      if(edit) checkIncDecModVar<-100,0>(event,&g_model.expoData[chn].expNormWeight,(sizeof(g_model.expoData[chn].expNormWeight)==2 ? 4 : 0)|2);
      break;
    case 2:
      putsDrSwitches(x,y,g_model.expoData[chn].drSw,invBlk);
      if(edit) checkIncDecModVar<0,(1+SW_Trainer-SW_ThrCt+1)>(event,&g_model.expoData[chn].drSw,(sizeof(g_model.expoData[chn].drSw)==2 ? 4 : 0)|2);
      break;
    case 3:
      lcd_outdezAtt(x, y, g_model.expoData[chn].expDr, invBlk);
      if(edit) checkIncDecModVar<-100,100>(event,&g_model.expoData[chn].expDr,(sizeof(g_model.expoData[chn].expDr)==2 ? 4 : 0)|2);
      break;
    case 4:
      lcd_outdezAtt(x, y, g_model.expoData[chn].expSwWeight+100, invBlk);
      if(edit) checkIncDecModVar<-100,0>(event,&g_model.expoData[chn].expSwWeight,(sizeof(g_model.expoData[chn].expSwWeight)==2 ? 4 : 0)|2);
      break;
  }
}

void menuProcExpoOne(uint8_t event)
{
  static MState2 mstate2;
  uint8_t x=lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("EXPO/DR ");&__c[0];})),0x01);
  putsChnRaw(x,0,s_expoChan+1,0);
  mstate2.check_v(event,0,0,0,5 -1);
  int8_t sub = mstate2.m_posVert;


  uint8_t y = 16;


  lcd_puts_P(0,y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Expo");&__c[0];})));
  editExpoVals(event,0,sub==0,9*6, y,s_expoChan);
  y+=8;

  lcd_puts_P(0,y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Weight");&__c[0];})));
  editExpoVals(event,1,sub==1,9*6, y,s_expoChan);
  y+=8;
  y+=8;

  lcd_puts_P(0,y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("DrSw");&__c[0];})));
  editExpoVals(event,2,sub==2,5*6, y,s_expoChan);
  y+=8;

  lcd_puts_P(0,y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("DrExp");&__c[0];})));
  editExpoVals(event,3,sub==3,9*6, y,s_expoChan);
  y+=8;

  lcd_puts_P(0,y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Weight");&__c[0];})));
  editExpoVals(event,4,sub==4,9*6, y,s_expoChan);
  y+=8;


  int8_t kView = 0;
  int8_t wView = 0;
  if(sub<=1){


    kView = g_model.expoData[s_expoChan].expNorm;
    wView = g_model.expoData[s_expoChan].expNormWeight+100;
  }else{
    if(sub<=3){
      kView =g_model.expoData[s_expoChan].expDr;
      wView =g_model.expoData[s_expoChan].expSwWeight+100;
    }
  }




  for(uint8_t xv=0;xv<32;xv++)
  {
    uint16_t yv=expo(xv*(512u/32),kView) / (512u/32);
    yv = (yv * wView)/100;
    lcd_plot((128-32 -2)+xv, 32 -yv);
    lcd_plot((128-32 -2)-xv, 32 +yv);
    if((xv&3) == 0){
      lcd_plot((128-32 -2)+xv, 32 +0);
      lcd_plot((128-32 -2)-xv, 32 +0);
      lcd_plot((128-32 -2) , 32 +xv);
      lcd_plot((128-32 -2) , 32 -xv);
    }
  }
  int16_t x512 = anaCalib[s_expoChan];
  int16_t y512 = expo(x512,kView);
  y512 = y512 * (wView / 4)/(100 / 4);

  lcd_vline((128-32 -2)+x512/(512u/32), 32 -32,32*2);
  lcd_hline((128-32 -2)-32, 32 -y512/(512u/32),32*2);
  lcd_outdezAtt( 19*6, 6*8,x512*25/((signed) 512u/4), 0 );
  lcd_outdezAtt( 14*6, 1*8,y512*25/((signed) 512u/4), 0 );


  int16_t dy = x512>0 ? y512-expo(x512-20,kView) : expo(x512+20,kView)-y512;
  lcd_outdezNAtt(14*6, 2*8, dy*(100/20), 0x04|0x40,3);
}
void menuProcExpoAll(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("EXPO/DR");&__c[0];})),0x01);
  static prog_uint8_t __attribute__(( section(".progmem.data") )) mstate_tab[] = {5,5};
  mstate2.check(event,3,menuTabModel,(sizeof((menuTabModel))/sizeof((menuTabModel)[0])),mstate_tab,(sizeof((mstate_tab))/sizeof((mstate_tab)[0]))-1,4+1 -1);
  int8_t sub = mstate2.m_posVert - 1;
  int8_t subHor = mstate2.m_posHorz;

  switch(event)
  {
    case ((KEY_MENU)| 0x40|0x20):
      if(sub>=0){
        s_expoChan = sub;
        pushMenu(menuProcExpoOne);
      }
      break;
  }

  lcd_puts_P( 4*6, 1*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("exp  % sw  exp  %");&__c[0];})));
  for(uint8_t i=0; i<4; i++)
  {
    uint8_t y=(i+2)*8;
    putsChnRaw( 0, y,i+1,0);
    editExpoVals(event,0,sub==i && subHor==0, 6*6, y,i);
    editExpoVals(event,1,sub==i && subHor==1,10*6, y,i);
    editExpoVals(event,2,sub==i && subHor==2,10*6, y,i);
    if(g_model.expoData[i].drSw){
      editExpoVals(event,3,sub==i && subHor==3,17*6, y,i);
      editExpoVals(event,4,sub==i && subHor==4,21*6, y,i);
    }else{
      if(sub==i && subHor>=3) mstate2.m_posHorz=2;
    }
  }
}
const prog_char __attribute__(( section(".progmem.data") )) s_charTab[]=" ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.";


uint8_t char2idx(char c)
{
  for(int8_t ret=0;;ret++)
  {
    char cc= (__extension__({ uint16_t __addr16 = (uint16_t)((uint16_t)(s_charTab+ret)); uint8_t __result; __asm__ ( "lpm %0, Z" "\n\t" : "=r" (__result) : "z" (__addr16) ); __result; }));
    if(cc==c) return ret;
    if(cc==0) return 0;
  }
}
char idx2char(uint8_t idx)
{
  if(idx < (sizeof(s_charTab)-1)) return (__extension__({ uint16_t __addr16 = (uint16_t)((uint16_t)(s_charTab+idx)); uint8_t __result; __asm__ ( "lpm %0, Z" "\n\t" : "=r" (__result) : "z" (__addr16) ); __result; }));
  return ' ';
}

void menuProcModel(uint8_t event)
{
  static MState2 mstate2;
  uint8_t x=lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("SETUP ");&__c[0];})),0x01);
  lcd_outdezNAtt(x+2*6,0,g_eeGeneral.currModel+1,0x01 +0x04,2);
  static prog_uint8_t __attribute__(( section(".progmem.data") )) mstate_tab[] = { 1,sizeof(g_model.name),2,3,1,1,1,1};
  mstate2.check(event,2,menuTabModel,(sizeof((menuTabModel))/sizeof((menuTabModel)[0])),mstate_tab,(sizeof((mstate_tab))/sizeof((mstate_tab)[0]))-1,8 -1);
  int8_t sub = mstate2.m_posVert;

  uint8_t subSub = mstate2.m_posHorz+1;

  lcd_putsAtt( 0, 1*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Name");&__c[0];})),sub==1 && subSub==0 ? 0x02:0);
  lcd_putsnAtt( 10*6, 1*8, g_model.name ,sizeof(g_model.name),0x10);

  lcd_putsAtt( 0, 2*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Proto");&__c[0];})),0);
  lcd_putsnAtt( 10*6, 2*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("PPM   SILV_ASILV_BSILV_CTRAC09");&__c[0];}))+6*g_model.protocol,6,
                 (sub==2 && subSub==1 ? 0x02:0));
  if(!g_model.protocol)
    lcd_putsnAtt( 14*6, 2*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("8CH 10CH12CH14CH16CH");&__c[0];}))+4*g_model.ppmNCH,4,(sub==2 && subSub==2 ? 0x02:0));

  lcd_putsAtt( 0, 3*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Timer");&__c[0];})),sub==3 && subSub==0 ? 0x02:0);
  putsTime( 9*6, 3*8, g_model.tmrVal,(sub==3 && subSub==1 ? 0x02:0),(sub==3 && subSub==2 ? 0x02:0) );

  lcd_putsnAtt( 16*6, 3*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("OFF ABS THR THR%");&__c[0];}))+4*g_model.tmrMode,4,(sub==3 && subSub==3 ? 0x02:0));

  lcd_putsAtt( 0, 4*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("T-Trim");&__c[0];})),0);
  lcd_putsnAtt( 10*6, 4*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("OFFON ");&__c[0];}))+3*g_model.thrTrim,3,(sub==4 ? 0x02:0));

  lcd_putsAtt( 0, 5*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Trim Inc");&__c[0];})),0);
  lcd_putsnAtt( 10*6, 5*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Exp   ExFineFine  MediumCoarse");&__c[0];}))+6*g_model.trimInc,6,(sub==5 ? 0x02:0));

  lcd_putsAtt( 0, 6*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("TCut SW");&__c[0];})),0);
  putsDrSwitches( 9*6, 6*8, g_model.tcutSW,(sub==6 ? 0x02:0));

  lcd_putsAtt( 0, (7)*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("RM");&__c[0];})),sub==7?0x02:0);
  lcd_puts_P( 6*6, (7)*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("remove [MENU]");&__c[0];})));

  switch(sub)
  {
    case 1:
      if(subSub) {
        char v = char2idx(g_model.name[subSub-1]);
        ( v=checkIncDec_hm(event,v,0,(sizeof(s_charTab)-1)-1), checkIncDec_Ret );
        v = idx2char(v);
        g_model.name[subSub-1]=v;
        lcd_putcAtt((10+subSub-1)*6, 1*8, v,0x02);
      }
      break;
    case 2:
      switch(subSub)
      {
        case 1:
          checkIncDecModVar<0,4>(event,&g_model.protocol,(sizeof(g_model.protocol)==2 ? 4 : 0)|2);
          break;
        case 2:
          checkIncDecModVar<0,4>(event,&g_model.ppmNCH,(sizeof(g_model.ppmNCH)==2 ? 4 : 0)|2);
          break;
      }
      break;
    case 3:
      switch(subSub)
      {
        case 1:
          {
          int8_t min=g_model.tmrVal/60;
          ( min=checkIncDec_hm(event,min,0,59), checkIncDec_Ret );
          g_model.tmrVal = g_model.tmrVal%60 + min*60;
         break;
          }
        case 2:
          {
          int8_t sec=g_model.tmrVal%60;
          sec -= checkIncDec_hm( event,sec+2 ,1,62)-2;
          g_model.tmrVal -= sec ;
          if((int16_t)g_model.tmrVal < 0) g_model.tmrVal=0;
          break;
          }
        case 3:
          ( g_model.tmrMode=checkIncDec_hm(event,g_model.tmrMode,0,3), checkIncDec_Ret );
          break;

      }
      break;
    case 4:
      checkIncDecModVar<0,1>(event,&g_model.thrTrim,(sizeof(g_model.thrTrim)==2 ? 4 : 0)|2);
      break;
    case 5:
      checkIncDecModVar<0,4>(event,&g_model.trimInc,(sizeof(g_model.trimInc)==2 ? 4 : 0)|2);
      break;
    case 6:
      checkIncDecModVar<-(1+SW_Trainer-SW_ThrCt+1),(1+SW_Trainer-SW_ThrCt+1)>(event,&g_model.tcutSW,(sizeof(g_model.tcutSW)==2 ? 4 : 0)|2);
      break;
    case 7:
      if(event==((KEY_MENU)|0x80)){
        killEvents(event);
        EFile::rm((1+g_eeGeneral.currModel));
        eeLoadModel(g_eeGeneral.currModel);
        chainMenu(menuProcModelSelect);
      }
      break;
  }
}
void menuProcModelSelect(uint8_t event)
{
  static uint8_t s_editMode;
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("MODELSEL");&__c[0];})),0x01);
  lcd_puts_P( 10*6, 0, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("free");&__c[0];})));
  lcd_outdezAtt( 18*6, 0, EeFsGetFree(),0);
  lcd_putsAtt(128-6*3,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("1/7");&__c[0];})),0x01);
  int8_t subOld = mstate2.m_posVert;
  mstate2.check_v(event,0,0,0,16 -1);
  int8_t sub = mstate2.m_posVert;
  static uint8_t s_pgOfs;
  switch(event)
  {

    case ((KEY_EXIT)| 0x40|0x20):
      if(s_editMode){
        s_editMode = false;
        _beep(g_beepVal[0]);
        killEvents(event);
        break;
      }

    case ((KEY_RIGHT)| 0x40|0x20):
      if(g_eeGeneral.currModel != mstate2.m_posVert)
      {
        eeLoadModel(g_eeGeneral.currModel = mstate2.m_posVert);
        eeDirty(1);
        s_limitCacheOk=false;
        _beep(g_beepVal[0]);
      }

      if(event==((KEY_RIGHT)| 0x40|0x20)) chainMenu(menuProcModel);
      break;
    case ((KEY_MENU)| 0x40|0x20):
      s_editMode = true;
      _beep(g_beepVal[0]);
      break;
    case ((KEY_MENU)|0x80):
      if(s_editMode){
        if(eeDuplicateModel(sub)) {
          _beep(g_beepVal[0]);
          s_editMode = false;
        }
        else _beep(g_beepVal[2]);
      }
      break;

    case (0xff - 0x40):
      s_editMode = false;

      mstate2.m_posVert = g_eeGeneral.currModel;
      eeCheck(true);
      break;
  }
  if(s_editMode && subOld!=sub){
    EFile::swap((1+subOld),(1+sub));
  }

  if(sub-s_pgOfs < 1) s_pgOfs = max(0,sub-1);
  else if(sub-s_pgOfs >4 ) s_pgOfs = min(16 -6,sub-4);
  for(uint8_t i=0; i<6; i++){
    uint8_t y=(i+2)*8;
    uint8_t k=i+s_pgOfs;
    lcd_outdezNAtt( 2*6, y, k+1, ((sub==k) ? (s_editMode ? 0x01 : 0x02 ) : 0) + 0x04,2);
    static char buf[sizeof(g_model.name)+5];
    eeLoadModelName(k,buf,sizeof(buf));
    lcd_putsnAtt( 3*6, y, buf,sizeof(buf),0x10|((sub==k) ? (s_editMode ? 0x02 : 0 ) : 0));
  }

}



void menuProcDiagCalib(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("CALIB");&__c[0];})),0x01);
  mstate2.check_v(event,7,menuTabDiag,(sizeof((menuTabDiag))/sizeof((menuTabDiag)[0])),5 -1);
  int8_t sub = mstate2.m_posVert ;
  static int16_t midVals[4];
  static int16_t lowVals[4];
  switch(event)
  {
    case ((KEY_DOWN)| 0x20):
      switch(sub)
      {
        case 2:

          for(uint8_t i=0; i<4; i++)midVals[i] = anaIn(i);
          _beep(g_beepVal[0]);
          break;
        case 3:

          for(uint8_t i=0; i<4; i++)lowVals[i] = anaIn(i);
          _beep(g_beepVal[0]);
          break;
        case 4:



          for(uint8_t i=0; i<4; i++){
            g_eeGeneral.calibMid[i] = midVals[i];



            uint16_t v;
            v = midVals[i] - lowVals[i];
            g_eeGeneral.calibSpanNeg[i] = v - v/64;
            v = anaIn(i)- midVals[i];
            g_eeGeneral.calibSpanPos[i] = v - v/64;
          }
          int16_t sum=0;
          for(uint8_t i=0; i<12;i++) sum+=g_eeGeneral.calibMid[i];
          g_eeGeneral.chkSum = sum;
          eeDirty(1);
          _beep(g_beepVal[0]);
          break;
      }
      break;
  }
  for(uint8_t i=1; i<5; i++)
  {
    uint8_t y=i*8 +8;
    lcd_putsnAtt( 0, y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("SetMid SetLow SetHighReady  ");&__c[0];}))+7*(i-1),7,
                    sub==i ? 0x02 : 0);
  }
  for(uint8_t i=0; i<4; i++)
  {
    uint8_t y=i*8 +0;
    lcd_putsn_P( 8*6, y, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("A1A2A3A4");&__c[0];}))+2*i,2);

    lcd_outhex4(12*6, y, anaIn(i));



    lcd_puts_P( 11*6, y+4*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("<    >");&__c[0];})));
    lcd_outhex4( 8*6 -3,y+4*8, g_eeGeneral.calibSpanNeg[i]);
    lcd_outhex4(12*6, y+4*8, g_eeGeneral.calibMid[i]);
    lcd_outhex4(17*6, y+4*8, g_eeGeneral.calibSpanPos[i]);
  }

}
void menuProcDiagAna(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("ANA");&__c[0];})),0x01);
  mstate2.check_v(event,6,menuTabDiag,(sizeof((menuTabDiag))/sizeof((menuTabDiag)[0])),2 -1);
  int8_t sub = mstate2.m_posVert ;

  for(uint8_t i=0; i<8; i++)
  {
    uint8_t y=i*8;
    lcd_putsn_P( 4*6, y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("A1A2A3A4A5A6A7A8");&__c[0];}))+2*i,2);

    lcd_outhex4( 8*6, y,anaIn(i));
    if(i<4){

      int16_t v = anaIn(i) - g_eeGeneral.calibMid[i];
      v = v*50/max(1, (v > 0 ? g_eeGeneral.calibSpanPos[i] : g_eeGeneral.calibSpanNeg[i])/2);
      lcd_outdez(17*6, y, v);

    }
    if(i==7){
      putsVBat(13*6,y,sub==1 ? 0x02 : 0);
    }
  }
  if(sub==1){
   checkIncDecModVar<-127,127>(event,&g_eeGeneral.vBatCalib,(sizeof(g_eeGeneral.vBatCalib)==2 ? 4 : 0)|1);
  }

}

void menuProcDiagKeys(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("DIAG");&__c[0];})),0x01);
  mstate2.check_v(event,5,menuTabDiag,(sizeof((menuTabDiag))/sizeof((menuTabDiag)[0])),1 -1);

  uint8_t x;

  x=7*6;
  for(uint8_t i=0; i<9; i++)
  {
    uint8_t y=i*8;
    if(i>(SW_ID0-SW_ThrCt)) y-=8;
    bool t=keyState((EnumKeys)(SW_ThrCt+i));
    putsDrSwitches(x,y,i+1,0);
    lcd_putcAtt(x+6*4+2, y,t+'0',t ? 0x01 : 0);
  }

  x=0;
  for(uint8_t i=0; i<6; i++)
  {
    uint8_t y=(5-i)*8 +2*8;
    bool t=keyState((EnumKeys)(KEY_MENU+i));
    lcd_putsn_P(x, y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = (" Menu Exit Down   UpRight Left");&__c[0];}))+5*i,5);
    lcd_putcAtt(x+6*5+2, y,t+'0',t);
  }


  x=14*6;
  lcd_putsn_P(x, 3*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Trim- +");&__c[0];})),7);
  for(uint8_t i=0; i<4; i++)
  {
    uint8_t y=i*8 +8*4;

    lcd_img( x, y, sticks,i,0);
    bool tm=keyState((EnumKeys)(TRM_LH_DWN+2*i));
    bool tp=keyState((EnumKeys)(TRM_LH_DWN+2*i+1));
    lcd_putcAtt(x+6*4, y, tm+'0',tm ? 0x01 : 0);
    lcd_putcAtt(x+6*6, y, tp+'0',tp ? 0x01 : 0);
  }
}
void menuProcDiagVers(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("VERSION");&__c[0];})),0x01);
  mstate2.check_v(event,4,menuTabDiag,(sizeof((menuTabDiag))/sizeof((menuTabDiag)[0])),1 -1);

  lcd_puts_P(0, 2*8,stamp4 );
  lcd_puts_P(0, 3*8,stamp1 );
  lcd_puts_P(0, 4*8,stamp2 );
  lcd_puts_P(0, 5*8,stamp3 );
}

void menuProcTrainer(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("TRAINER");&__c[0];})),0x01);
  static prog_uint8_t __attribute__(( section(".progmem.data") )) mstate_tab[] = { 4,4};
  mstate2.check(event,3,menuTabDiag,(sizeof((menuTabDiag))/sizeof((menuTabDiag)[0])),mstate_tab,(sizeof((mstate_tab))/sizeof((mstate_tab)[0]))-1,1+4+1 -1);
  int8_t sub = mstate2.m_posVert-1 ;
  uint8_t subSub = mstate2.m_posHorz+1;
  uint8_t y;
  bool edit;

  lcd_puts_P( 3*6, 1*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("mode prc src swt");&__c[0];})));
  for(uint8_t i=0; i<4; i++){
    y=(i+2)*8;
    TrainerData1* td = &g_eeGeneral.trainer.chanMix[i];
    putsChnRaw( 0, y,i+1,
                sub==i ? (subSub==0 ? 0x02 : 0x01) : 0);
    edit = (sub==i && subSub==1);
    lcd_putsnAtt( 4*6, y, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("off += :=");&__c[0];}))+3*td->mode,3,
                    edit ? 0x02 : 0);
    if(edit) td->mode = checkIncDec_hg( event, td->mode, 0,2);

    edit = (sub==i && subSub==2);
    lcd_outdezAtt( 11*6, y, td->studWeight*13/4,
                   edit ? 0x02 : 0);
    if(edit) td->studWeight = checkIncDec_hg( event, td->studWeight, -31,31);

    edit = (sub==i && subSub==3);
    lcd_putsnAtt( 12*6, y, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("ch1ch2ch3ch4");&__c[0];}))+3*td->srcChn,3, edit ? 0x02 : 0);
    if(edit) td->srcChn = checkIncDec_hg( event, td->srcChn, 0,3);

    edit = (sub==i && subSub==4);
    putsDrSwitches(15*6, y, td->swtch, edit ? 0x02 : 0);
    if(edit) td->swtch = checkIncDec_hg( event, td->swtch, -(1+SW_Trainer-SW_ThrCt+1), (1+SW_Trainer-SW_ThrCt+1));


  }
  edit = (sub==4);
  y = 7*8;
  lcd_putsnAtt( 0*6, y, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Cal");&__c[0];})),3,(sub==4) ? 0x02 : 0);
  for(uint8_t i=0; i<4; i++)
  {
    uint8_t x = (i*8+16)*6/2;
    lcd_outdezAtt( x , y, (g_ppmIns[i]-g_eeGeneral.trainer.calib[i])*2,0x20 );
  }
  if(edit)
  {
    if(event==((KEY_MENU)| 0x40|0x20)){
      memcpy(g_eeGeneral.trainer.calib,g_ppmIns,sizeof(g_eeGeneral.trainer.calib));
      eeDirty(1);
      _beep(g_beepVal[0]);
    }
  }

}
void menuProcSetup1(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("SETUP OPTS");&__c[0];})),0x01);
  mstate2.check_v(event,2,menuTabDiag,(sizeof((menuTabDiag))/sizeof((menuTabDiag)[0])),1+4 -1);
  int8_t sub = mstate2.m_posVert-1 ;
  for(uint8_t i=0; i<4; i++){
    uint8_t y=i*8 +2*8;
    uint8_t attr = sub==i ? 0x02 : 0;
    lcd_putsnAtt( 6*7,y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("THR Warn" "SW  Warn" "Mem Warn" "Beeper  ");&__c[0];}))+i*8,8,0);



    switch(i){
      case 0:
      case 1:
      case 2:
        {
          uint8_t bit = 1<<i;
          bool val = !(g_eeGeneral.warnOpts & bit);
          lcd_putsAtt( 6*3, y, val ? (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("ON");&__c[0];})): (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("OFF");&__c[0];})),attr);
          if(attr) val = checkIncDec_hg( event, val, 0, 1);
          g_eeGeneral.warnOpts |= bit;
          if(val) g_eeGeneral.warnOpts &= ~bit;
          break;
        }
      case 3:
        uint8_t bits = 3<<i;
        uint8_t val = (g_eeGeneral.warnOpts & bits)>>3;
        lcd_outdezAtt( 6*4, y, val,attr);
        if(attr) val = checkIncDec_hg( event, val, 0, 3);
        g_eeGeneral.warnOpts = (g_eeGeneral.warnOpts & ~bits) | (val<<3);
        break;
    }
  }
}
void menuProcSetup0(uint8_t event)
{
  static MState2 mstate2;
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("SETUP BASIC");&__c[0];})),0x01);
  mstate2.check_v(event,1,menuTabDiag,(sizeof((menuTabDiag))/sizeof((menuTabDiag)[0])),1+4 -1);
  int8_t sub = mstate2.m_posVert-1 ;
  uint8_t y=2*8;
  lcd_outdezAtt(4*6,y,g_eeGeneral.contrast,sub==0 ? 0x02 : 0);
  if(sub==0){
    checkIncDecModVar<20,45>(event,&g_eeGeneral.contrast,(sizeof(g_eeGeneral.contrast)==2 ? 4 : 0)|1);
    lcdSetRefVolt(g_eeGeneral.contrast);
  }
  lcd_puts_P( 6*6, y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("CONTRAST");&__c[0];})));
  y+=8;

  lcd_outdezAtt(4*6,y,g_eeGeneral.vBatWarn,(sub==1 ? 0x02 : 0)|0x20);
  if(sub==1){
    checkIncDecModVar<50,100>(event,&g_eeGeneral.vBatWarn,(sizeof(g_eeGeneral.vBatWarn)==2 ? 4 : 0)|1);
  }
  lcd_puts_P( 4*6, y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("V BAT WARNING");&__c[0];})));
  y+=8;

  putsDrSwitches(0*6,y,g_eeGeneral.lightSw,sub==2 ? 0x02 : 0);
  if(sub==2){
    checkIncDecModVar<-(1+SW_Trainer-SW_ThrCt+1),(1+SW_Trainer-SW_ThrCt+1)>(event,&g_eeGeneral.lightSw,(sizeof(g_eeGeneral.lightSw)==2 ? 4 : 0)|1);
  }
  lcd_puts_P( 6*6, y,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("LIGHT");&__c[0];})));


  y+=2*8;
  lcd_putsAtt( 1*6, y, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Mode");&__c[0];})),0);
  lcd_putcAtt( 3*6, y+8, '1'+g_eeGeneral.stickMode,sub==3?0x02:0);
  for(uint8_t i=0; i<4; i++)
  {
    lcd_img( (6+4*i)*6, y, sticks,i,0);
    putsChnRaw( (6+4*i)*6, y+8,i+1,0);
  }
  if(sub==3){
    checkIncDecModVar<0,3>(event,&g_eeGeneral.stickMode,(sizeof(g_eeGeneral.stickMode)==2 ? 4 : 0)|1);
  }
}

uint16_t s_timeCumTot;
uint16_t s_timeCumAbs;
uint16_t s_timeCumThr;
uint16_t s_timeCum16ThrP;
uint8_t s_timerState;




int16_t s_timerVal;
void timer(uint8_t val)
{
  static uint16_t s_time;
  static uint16_t s_cnt;
  static uint16_t s_sum;
  s_cnt++;
  s_sum+=val;
  if((g_tmr10ms-s_time)<100)
    return;
  s_time += 100;
  val = s_sum/s_cnt;
  s_sum -= val*s_cnt;
  s_cnt = 0;

  s_timeCumTot += 1;
  s_timeCumAbs += 1;
  if(val) s_timeCumThr += 1;
  s_timeCum16ThrP += val/2;

  s_timerVal = g_model.tmrVal;
  switch(g_model.tmrMode)
  {
    case 0:
      s_timerState = 0;
      return;
    case 3:
      s_timerVal -= s_timeCum16ThrP/16;

      break;
    case 2:
      s_timerVal -= s_timeCumThr;

      break;
    case 1:
      s_timerVal -= s_timeCumAbs;

      break;
  }
  switch(s_timerState)
  {
    case 0:
      if(g_model.tmrMode != 0) s_timerState=1;
      break;
    case 1:
      if(s_timerVal<=0 && g_model.tmrVal) s_timerState=2;
      break;
    case 2:
      if(s_timerVal <= -60) s_timerState=3;
      if(g_model.tmrVal == 0) s_timerState=1;
      break;
    case 3:
      break;
  }

  if(s_timerState==2){
    static int16_t last_tmr;
    if(last_tmr != s_timerVal){
      last_tmr = s_timerVal;
      _beep(g_beepVal[1]);
    }
  }
}



uint8_t s_traceBuf[120];
uint16_t s_traceWr;
uint16_t s_traceCnt;
void trace(uint8_t val)
{
  timer(val);
  static uint16_t s_time;
  static uint16_t s_cnt;
  static uint16_t s_sum;
  s_cnt++;
  s_sum+=val;
  if((g_tmr10ms-s_time)<1000)
    return;
  s_time= g_tmr10ms;
  val = s_sum/s_cnt;
  s_sum = 0;
  s_cnt = 0;


  s_traceCnt++;
  s_traceBuf[s_traceWr++] = val;
  if(s_traceWr>=120) s_traceWr=0;
}


uint16_t g_tmr1Latency_max;
uint16_t g_tmr1Latency_min = 0x7ff;
uint16_t g_timeMain;
void menuProcStatistic2(uint8_t event)
{
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("STAT2");&__c[0];})),0x01);
  switch(event)
  {
    case ((KEY_MENU)| 0x40|0x20):
      g_tmr1Latency_min = 0x7ff;
      g_tmr1Latency_max = 0;
      g_timeMain = 0;
      _beep(g_beepVal[0]);
      break;
    case ((KEY_DOWN)| 0x40|0x20):
      chainMenu(menuProcStatistic);
      break;
    case ((KEY_UP)| 0x40|0x20):
    case ((KEY_EXIT)| 0x40|0x20):
      chainMenu(menuProc0);
      break;
  }
  lcd_puts_P( 0*6, 1*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("tmr1Lat max    us");&__c[0];})));
  lcd_outdez(14*6 , 1*8, g_tmr1Latency_max/2 );
  lcd_puts_P( 0*6, 2*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("tmr1Lat min    us");&__c[0];})));
  lcd_outdez(14*6 , 2*8, g_tmr1Latency_min/2 );
  lcd_puts_P( 0*6, 3*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("tmr1 Jitter    us");&__c[0];})));
  lcd_outdez(14*6 , 3*8, (g_tmr1Latency_max - g_tmr1Latency_min) /2 );
  lcd_puts_P( 0*6, 4*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("tmain          ms");&__c[0];})));
  lcd_outdez(14*6 , 4*8, g_timeMain/16 );
}

void menuProcStatistic(uint8_t event)
{
  lcd_putsAtt(0,0,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("STAT");&__c[0];})),0x01);
  switch(event)
  {
    case ((KEY_UP)| 0x40|0x20):
      chainMenu(menuProcStatistic2);
      break;
    case ((KEY_DOWN)| 0x40|0x20):
    case ((KEY_EXIT)| 0x40|0x20):
      chainMenu(menuProc0);
      break;
  }

  lcd_puts_P( 1*6, 8*1, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("TME");&__c[0];})));
  putsTime( 4*6, 8*1, s_timeCumAbs, 0, 0);
  lcd_puts_P( 17*6, 8*1, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("TOT");&__c[0];})));
  putsTime( 10*6, 8*1, s_timeCumTot, 0, 0);

  lcd_puts_P( 1*6, 8*2, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("THR");&__c[0];})));
  putsTime( 4*6, 8*2, s_timeCumThr, 0, 0);
  lcd_puts_P( 17*6, 8*2, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("THR%");&__c[0];})));
  putsTime( 10*6, 8*2, s_timeCum16ThrP/16, 0, 0);


  uint16_t traceRd = s_traceCnt>120 ? s_traceWr : 0;
  uint8_t x=5;
  uint8_t y=60;
  lcd_hline(x-3,y,120+3+3);
  lcd_vline(x,y-32,32+3);

  for(uint8_t i=0; i<120; i+=6)
  {
    lcd_vline(x+i+6,y-1,3);
  }
  for(uint8_t i=1; i<=120; i++)
  {
    lcd_vline(x+i,y-s_traceBuf[traceRd],s_traceBuf[traceRd]);
    traceRd++;
    if(traceRd>=120) traceRd=0;
    if(traceRd==s_traceWr) break;
  }

}

extern volatile uint16_t captureRing[16];


void menuProc0(uint8_t event)
{



  static uint8_t sub;
  static MenuFuncP s_lastPopMenu[2];

  switch(event)
  {
    case ((KEY_MENU)|0x80):
      switch(sub){
        case 0:
          pushMenu(menuProcSetup0);
          break;
        case 1:
          pushMenu(menuProcModelSelect);
          break;
      }
      killEvents(event);
      break;
    case ((KEY_RIGHT)| 0x40|0x20):
      if(getEventDbl(event)==2 && s_lastPopMenu[1]){
        pushMenu(s_lastPopMenu[1]);
        break;
      }
      if(sub<1) {
        sub=sub+1;
        _beep(g_beepVal[0]);
      }
      break;
    case ((KEY_RIGHT)|0x80):
      pushMenu(menuProcModelSelect);
      killEvents(event);
      break;
    case ((KEY_LEFT)| 0x40|0x20):
      if(getEventDbl(event)==2 && s_lastPopMenu[0]){
        pushMenu(s_lastPopMenu[0]);
        break;
      }
      if(sub>0) {
        sub=sub-1;
        _beep(g_beepVal[0]);
      }
      break;
    case ((KEY_LEFT)|0x80):
      pushMenu(menuProcSetup0);
      killEvents(event);
      break;

    case ((KEY_UP)| 0x20):
      g_eeGeneral.view += 2;
    case ((KEY_DOWN)| 0x20):
      g_eeGeneral.view += 2 -1;
      g_eeGeneral.view %= 2;
      eeDirty(1);
      _beep(g_beepVal[0]);
      break;
    case ((KEY_UP)|0x80):
      chainMenu(menuProcStatistic);
      killEvents(event);
      break;
    case ((KEY_DOWN)|0x80):
      chainMenu(menuProcStatistic2);
      killEvents(event);
      break;
    case ((KEY_EXIT)| 0x40|0x20):
      if(s_timerState==2) {
        s_timerState = 3;
        _beep(g_beepVal[0]);
      }
      break;
    case ((KEY_EXIT)|0x80):
      s_timerState = 0;
      s_timeCumAbs=0;
      s_timeCumThr=0;
      s_timeCum16ThrP=0;
      _beep(g_beepVal[0]);
      break;
    case (0xfe - 0x40):
      s_lastPopMenu[sub] = lastPopMenu();
    case (0xff - 0x40):
      killEvents(KEY_EXIT);
      killEvents(KEY_UP);
      killEvents(KEY_DOWN);
      break;
  }


  uint8_t x=6*2;
  lcd_putsAtt(x,0*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("ER9x");&__c[0];})),sub==0 ? 0x01 : 0);
  lcd_putsnAtt(x,1*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("Exp ExF Fine Med Crse");&__c[0];}))+4*g_model.trimInc,4, 0);
  lcd_putsnAtt(x,2*8,(__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("    TTrm");&__c[0];}))+4*g_model.thrTrim,4, 0);

  lcd_putsnAtt(x+ 5*6, 0*8, g_model.name ,sizeof(g_model.name),sub==1 ? 0x11 : 0x10);

  lcd_puts_P( x+ 5*6, 1*8, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("BAT");&__c[0];})));
  putsVBat(x+ 8*6,1*8, g_vbat100mV < g_eeGeneral.vBatWarn ? 0x02 : 0);


  if(s_timerState != 0){

    uint8_t att = 0x80 | (s_timerState==2 ? 0x02 : 0);

    putsTime( x+8*6, 8*2, s_timerVal, att,att);
    lcd_putsnAtt( x+ 5*6, 8*2, (__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("TME THR THR%");&__c[0];}))-4+4*g_model.tmrMode,4,0);
  }

  for(uint8_t i=0; i<4; i++)
  {


    static uint8_t x[4] = {128*1/4+2, 4, 128-4, 128*3/4-2};
    static uint8_t vert[4] = {0,1,1,0};
    uint8_t xm,ym;
    xm=x[i];
    int8_t val = max((int8_t)-(27 +1),min((int8_t)(27 +1),(int8_t)(g_model.trimData[i].trim/4)));
    if(vert[i]){
      ym=31;
      lcd_vline(xm, ym-27, 27*2);

      if(((g_eeGeneral.stickMode&1) != (i&1)) || !(g_model.thrTrim==1)){
    lcd_vline(xm-1, ym-1, 3);
        lcd_vline(xm+1, ym-1, 3);
      }

      ym -= val;
    }else{
      ym=60;
      lcd_hline(xm-27,ym, 27*2);
      lcd_hline(xm-1, ym-1, 3);
      lcd_hline(xm-1, ym+1, 3);

      xm += val;
    }



    lcd_vline(xm-7/2,ym-7/2,7);
    lcd_hline(xm-7/2,ym+7/2,7);
    lcd_vline(xm+7/2,ym-7/2,7);
    lcd_hline(xm-7/2,ym-7/2,7);
  }
  for(uint8_t i=0; i<8; i++)
  {
    uint8_t x0,y0;
    switch(g_eeGeneral.view)
    {
      case 0:
        x0 = (i%4*9+3)*6/2;
        y0 = i/4*8 +40;

        lcd_outdezAtt( x0+4*6 , y0, g_chans512[i]*2-g_chans512[i]/21,0x20 );
        break;
      case 1:

        x0 = i<4 ? 128/4+4 : 128*3/4-4;
        y0 = 38+(i%4)*5;
        int8_t l = (abs(g_chans512[i])+(50/2)/2) * (50/2) / 512;
        if(l>(50/2)) l = (50/2);

        lcd_hlineStip(x0-(50/2),y0,(50/2)*2+1,0x55);
        lcd_vline(x0,y0-2,5);
        if(g_chans512[i]>0){
          x0+=1;
        }else{
          x0-=l;
        }
        lcd_hline(x0,y0+1,l);
        lcd_hline(x0,y0-1,l);
        break;
    }
  }

}

static int16_t s_cacheLimitsMin[16];
static int16_t s_cacheLimitsMax[16];
void calcLimitCache()
{
  if(s_limitCacheOk) return;



  s_limitCacheOk = true;
  for(uint8_t i=0; i<16; i++){
    int16_t v = g_model.limitData[i].min-100;
    s_cacheLimitsMin[i] = v*4;
    v = g_model.limitData[i].max+100;
    s_cacheLimitsMax[i] = v*4;
  }
}




int16_t intpol(int16_t x, uint8_t idx)
{


  bool cv9 = idx >= 8;
  int8_t *crv = cv9 ? g_model.curves9[idx-8] : g_model.curves5[idx];
  int16_t erg;

  x+=512u;
  if(x < 0) {
    erg = crv[0] * (512/2);
  } else if(x >= (512*2)) {
    erg = crv[(cv9 ? 8 : 4)] * (512/2);
  } else {
    int16_t a,dx;
    if(cv9){
      a = (uint16_t)x / (512 * 2 / 8);
      dx =((uint16_t)x % (512 * 2 / 8)) * 2;
    } else {
      a = (uint16_t)x / (512 * 2 / 4);
      dx = (uint16_t)x % (512 * 2 / 4);
    }
    erg = (int16_t)crv[a]*((512 * 2 / 4)-dx) + (int16_t)crv[a+1]*(dx);
  }
  return erg / 50;
}

int16_t get_calibrated_stick(uint8_t i)
{
    int16_t v = anaIn(i);
    v -= g_eeGeneral.calibMid[i];
    v = v * (int32_t)512 / (max((int16_t)100,
                                    (v>0 ?
                                     g_eeGeneral.calibSpanPos[i] :
                                     g_eeGeneral.calibSpanNeg[i])));

    if(v <= -512) v = -512;
    if(v >= 512) v = 512;
    return v;
}

uint16_t pulses2MHz[60];


void perOut(int16_t *chanOut)
{
  static int16_t anas [(16 +9+0)];
  static int32_t chans [16];

         int16_t trimA [4];

  for(uint8_t i=0;i<4;i++){



    int16_t v = get_calibrated_stick(i);
    anaCalib[i] = v;

    v = expo(v,
              getSwitch(g_model.expoData[i].drSw,0) ?
              g_model.expoData[i].expDr :
              g_model.expoData[i].expNorm
    );
    int32_t x = (int32_t)v * (getSwitch(g_model.expoData[i].drSw,0) ?
                              g_model.expoData[i].expSwWeight+100 :
                              g_model.expoData[i].expNormWeight+100) / 100;
    v = (int16_t)x;

    TrainerData1* td = &g_eeGeneral.trainer.chanMix[i];
    if(td->mode && getSwitch(td->swtch,1)){
      uint8_t chStud = td->srcChn;
      int16_t vStud = (g_ppmIns[chStud]- g_eeGeneral.trainer.calib[chStud])*
        td->studWeight/31;

      switch(td->mode)
      {
        case 1: v += vStud; break;
        case 2: v = vStud; break;
      }
    }

    int32_t vv = 2*512;


    if((2-(g_eeGeneral.stickMode&1)) == i)
    {
      trace((v+512) / 32);
      if (g_model.thrTrim==1) vv = (int32_t)g_model.trimData[i].trim*(512 -v)/(2*512);
    }


    trimA[i] = (vv==2*512) ? g_model.trimData[i].trim : (int16_t)vv;
    trimA[i] += g_model.trimData[i].trimDef;
    if(getSwitch(g_model.tcutSW,false) && ((2-(g_eeGeneral.stickMode&1)) == i)){
      v=-512;
      trimA[i] = -125;
    }
    anas[i] = v;
  }
  for(uint8_t i=4;i<7;i++){
    int16_t v= anaIn(i);
    anas[i] = v-512;
  }
  anas[7] = 512;
  anas[8] = 512;
  for(uint8_t i=9;i<(16 +9+0);i++) anas[i] = chans[i-9];

  memset(chans,0,sizeof(chans));



    for(uint8_t i=0;i<25;i++){
      MixData &md = g_model.mixData[i];

      static uint8_t timer[25];
      static int16_t act [25];

      if((md.destCh==0) || (md.destCh>16)) break;



      if( !getSwitch(md.swtch,1) &&
          md.srcRaw != 8 &&
          md.srcRaw != 9
      )
        continue;

      int16_t v;
      v = !getSwitch(md.swtch,1) ? (md.srcRaw == 9 ? -512 : 0) : anas[md.srcRaw-1];

      if (md.speedUp || md.speedDown)
      {
# 1873 "../src/menus.cpp"
        static prog_uint8_t __attribute__(( section(".progmem.data") )) dlt_t[]={18,13,9,6,4,3,2,3,1,2,1,1,1,1,1};
        static prog_uint8_t __attribute__(( section(".progmem.data") )) tmr_t[]={ 1, 1,1,1,1,1,1,2,1,3,2,3,4,6,9};
        int16_t diff = v - act[i];
        if(diff){
          uint8_t speed = (diff > 0) ? md.speedUp : md.speedDown;
          if(speed){
            uint8_t timerend = (__extension__({ uint16_t __addr16 = (uint16_t)((uint16_t)(&tmr_t[speed-1])); uint8_t __result; __asm__ ( "lpm %0, Z" "\n\t" : "=r" (__result) : "z" (__addr16) ); __result; }));
            int8_t dlt = (__extension__({ uint16_t __addr16 = (uint16_t)((uint16_t)(&dlt_t[speed-1])); uint8_t __result; __asm__ ( "lpm %0, Z" "\n\t" : "=r" (__result) : "z" (__addr16) ); __result; }));
            dlt = min((int16_t)dlt, abs(diff)) ;
            if(diff < 0) dlt = -dlt;

            if (--timer[i] != 0)
            {
              if (timer[i] > timerend) timer[i] = timerend;
            }
            else
            {
              act[i] += dlt;
              timer[i] = timerend;
            }
          }else{
            act[i] = v;
            timer[i] = 0;
          }
        }
        v = act[i];
      }
      switch(md.curve){
        case 0:
          break;
        case 1:
          if(md.srcRaw == 9)
          {
            if( v<0 ) v=-512;
            else v=-512+2*v;
          }else{
            if( v<0 ) v=0;
          }
          break;
        case 2:
          if(md.srcRaw == 9)
          {
            if( v>0 ) v=512;
            else v=512+2*v;
          }else{
            if( v>0 ) v=0;
          }
          break;
        case 3: v = abs(v); break;
        default:

          v = intpol(v, md.curve - 4);
      }

      if((md.carryTrim==0) && (md.srcRaw>0) && (md.srcRaw<=4)) v += trimA[md.srcRaw-1];
      int32_t dv=(int32_t)v*(md.weight);
      chans[md.destCh-1] += dv;
    }



  calcLimitCache();
  for(uint8_t i=0;i<16;i++){
    int16_t v = 0;
    if(chans[i]) v = chans[i] >> 3;

    int32_t vv = (int32_t)v*123*4 / (512*12);
    chans[i] = (int16_t)vv;



    vv = (v>0) ? (int32_t)v*s_cacheLimitsMax[i]/(512*12) : (int32_t)-v*s_cacheLimitsMin[i]/(512*12);
    v = (int16_t)vv;


    v+=g_model.limitData[i].offset;
    if(g_model.limitData[i].revert) v=-v;
    if(v>512) v = 512;
    if(v<-512) v = -512;

    __asm__ __volatile__ ("cli" ::);
    chanOut[i] = v;
    __asm__ __volatile__ ("sei" ::);
  }


}
# 1969 "../src/menus.cpp"
void setupPulses()
{
  switch(g_model.protocol)
  {
    case 0:
      setupPulsesPPM();
      break;
    case 1:
    case 2:
    case 3:
      setupPulsesSilver();
      break;
    case 4:
      setupPulsesTracerCtp1009();
      break;
  }
}

void setupPulsesPPM()
{



  uint16_t rest=22500u*2;
  uint8_t j=0;
  uint8_t p=8+g_model.ppmNCH*2;
  for(uint8_t i=0;i<p;i++){
    int16_t v = g_chans512[i];
    v = 2*v - v/21 + 1200*2;
    rest-=v;
    pulses2MHz[j++]=300*2;
    pulses2MHz[j++]=v;
  }
  pulses2MHz[j++]=300*2;
  pulses2MHz[j++]=rest;
  pulses2MHz[j++]=0;

}


uint16_t *pulses2MHzPtr;

void _send_hilo(uint16_t hi,uint16_t lo)
{
  *pulses2MHzPtr++=hi; *pulses2MHzPtr++=lo;
}


void sendBitSilv(uint8_t val)
{
  _send_hilo( ((val)?2:1)*(600u*2),((val)?2:1)*(600u*2) );
}
void send2BitsSilv(uint8_t val)
{
  sendBitSilv(val&2);sendBitSilv(val&1);
}
# 2037 "../src/menus.cpp"
void setupPulsesSilver()
{
  int8_t chan=1;

  switch(g_model.protocol)
  {
    case 1: chan=0; break;
    case 2: chan=2; break;
    case 3: chan=1; break;
  }

  int8_t m1 = (uint16_t)(g_chans512[0]+512)*4 / 256;
  int8_t m2 = (uint16_t)(g_chans512[1]+512)*4 / 256;
  if (m1 < 0) m1=0;
  if (m2 < 0) m2=0;
  if (m1 > 15) m1=15;
  if (m2 > 15) m2=15;
  if (m2 > m1+9) m1=m2-9;
  if (m1 > m2+9) m2=m1-9;

  pulses2MHzPtr=pulses2MHz;
  _send_hilo( (5)*(600u*2),(1)*(600u*2) );
  send2BitsSilv(0);
  _send_hilo( (2)*(600u*2),(1)*(600u*2) );
  _send_hilo( (2)*(600u*2),(1)*(600u*2) );

  send2BitsSilv(chan);
  uint8_t sum = 0 - chan;

  send2BitsSilv(m1>>2);
  sum-=m1>>2;
  send2BitsSilv(m1);
  sum-=m1;

  send2BitsSilv(m2>>2);
  sum-=m2>>2;
  send2BitsSilv(m2);
  sum-=m2;

  send2BitsSilv(sum);

  sendBitSilv(0);
  pulses2MHzPtr--;
  _send_hilo( (50)*(600u*2),(0)*(600u*2) );


}
# 2122 "../src/menus.cpp"
void sendBitTra(uint8_t val)
{
  if(val) _send_hilo( (400u*2)*1 , (400u*2)*2 );
  else _send_hilo( (400u*2)*2 , (400u*2)*1 );
}
void sendByteTra(uint8_t val)
{
  for(uint8_t i=0; i<8; i++, val>>=1) sendBitTra(val&1);
}
void setupPulsesTracerCtp1009()
{
  pulses2MHzPtr=pulses2MHz;
  static bool phase;
  if( (phase=!phase) ){
    uint8_t thr = min(127u,(uint16_t)(g_chans512[0]+512+4) / 8u);
    uint8_t rot;
    if (g_chans512[1] >= 0)
    {
      rot = min(63u,(uint16_t)( g_chans512[1]+8) / 16u) | 0x40;
    }else{
      rot = min(63u,(uint16_t)(-g_chans512[1]+8) / 16u);
    }



    sendByteTra(thr);
    sendByteTra(rot);
    uint8_t chk=thr^rot;
    sendByteTra( (chk>>4) | (chk<<4) );
    _send_hilo( 5000*2, 2000*2 );
  }else{
    uint8_t fwd = min(127u,(uint16_t)(g_chans512[2]+512) / 8u) | 0x80;



    sendByteTra(fwd);
    sendByteTra(0x8e);
    uint8_t chk=fwd^0x8e;
    sendByteTra( (chk>>4) | (chk<<4) );
    _send_hilo( 7000*2, 2000*2 );
  }
  *pulses2MHzPtr++=0;
  if((pulses2MHzPtr-pulses2MHz) >= (signed)(sizeof((pulses2MHz))/sizeof((pulses2MHz)[0]))) alert((__extension__({static prog_char __attribute__(( section(".progmem.data") )) __c[] = ("pulse tab overflow");&__c[0];})));
}
